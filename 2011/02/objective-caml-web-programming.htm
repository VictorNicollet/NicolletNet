@title Objective Caml Web Programming
@date 2011-02-17
@tags functional ocaml architecture productivity web start-up
@draft

The core RunOrg¹ application clocks in at about 30K lines of Objective Caml code, with around 2K being added every week. If you factor in <a href="http://www.nicollet.net/2011/02/couchdb-architecture/" target="_blank">our use of CouchDB</a>, all of this might strike you as an odd choice of technologies, based on esoteric hopeful fantasies instead of cold pragmatical consideration. It isn't, <a href="http://maradydd.livejournal.com/293666.html" target="_blank">despite what others might say</a>:
<blockquote>OCaml: You know yourself to be fast, smart, and extremely reliable. However, you look kind of funny and nobody really wants to talk to you. You spend most of your time sitting in a public library glaring at people, occasionally yelling "NOBODY HERE APPRECIATES MY GENIUS!" and getting kicked out.</blockquote>
Two years ago, I discussed the topic of using <a href="http://www.nicollet.net/2009/02/ocaml-web-sites/" target="_blank">Objective Caml for web programming</a>:
<blockquote>What would happen if a compact web framework were proposed? One that, in addition to borrowing existing useful concepts from other languages, also added some OCaml-specific features to the mix. Functional modules would be an interesting addition, so would be the type system and pure functional programming applied to transactions, and monadic optimization at initialization time would also be quite interesting.</blockquote>
<h4>Eliom</h4>
Let's get this out of the way first. I have been continuously peeking at <a href="http://ocsigen.org/" target="_blank">Ocsigen - Eliom</a> (a web server and assorted web framework) ever since it was mentioned in a comment, and some aspects of it resonated with me while others really did not. In many ways, it served as a showcase of the many ways in which the peculiarities of Objective Caml can impact the development of a web project, and helped me decide whether these were appropriate or not. This evolved into my own rendition of a web framework, <strong>Ozone</strong>, connected to an apache server through OcamlNet2-powered FastCGI.

There were many reasons for avoiding Ocsigen - Eliom, though I do not believe any of them to be universally true. The main reason was described in Guillaume Yziquel's comment on that article:
<blockquote>Somehow, even a Ruby on Rails app is a state machine. Perhaps a “better state machine”, but a state machine nonetheless, in the sense that incoming requests interact with each other by modifying the internal data.

With Ocsigen / Eliom, it’s completely different: it’s a “safely” multithreaded, compiled, application. And that makes all the difference.</blockquote>
Based on my experience with Ocsigen - Eliom, I fully agree with this assertion, but consider it a liability in my situation. Our business plans call for a number of users that cannot be safely expected to all run out of a single server, be it multi-threaded, for both scaling and redundancy reasons. At some point, the only communication bridge between two requests <em>will</em> be the database back-end, and I need my web framework to accept that and actually make sure that my one-server code will gracefully scale up to a multi-server setup.

On a more philosophical level, I agree that «<em>On [the] server side, somehow, the “state machine” paradigm has been a hindrance</em>», but HTTP being what it is this is a basic truth that will not go away. Eliom is building an abstraction on top of it that will continuously spring leaks whenever the disconnected nature of HTTP surfaces. This is what ASP.NET and countless other technologies tried to do and they have all made the fall back to HTTP harder when the situation <em>did</em> eventually ask for it.

Ozone is also a compiled application, but it has <em>one</em> thread and <em>no</em> sessions — scaling happens by launching more instances of the application and therefore supports transparently the addition or removal of servers, while "session data" is stored in a combination of client-side state, database storage and HMAC proof tokens in the URLs. While this ascetic approach cuts me off from the sheer <em>sexy</em> of what Eliom allows, the tradeoff is a fairly convenient set of scalability guarantees. But if you can afford all that Eliom <em>sexy</em>, then I have no issue with that.
<h4>Benefits of OCaml</h4>
This is why I use Objective Caml, in no particular order.
<ul>
	<li><strong>It's fast <em>out of the box</em></strong> — OCaml is on par with C performance as long as you don't stray too far into sub-optimal areas (such as naive string concatenation). I can write any kind of code and be assured that it will not be the bottleneck, because database access and HTTP are a lot slower: right now, the average HTTP request takes about 80ms, with about 60ms for the actual HTTP transfer, 18ms for database latency, and 2ms for all of the Apache-FastCGI-Ozone sequence <em>when compiled without optimizations</em>.</li>
	<li><strong>It's a compiled application</strong>. This one is mostly aimed at my PHP friends, where every request starts a new PHP execution from scratch — this makes it several designs impossible or impractical, such as event-based programming: this would require B to register as a listener to A's event, which means B should be <em>identified as a potential listener</em> and loaded for every request <em>even if it does not trigger the event</em>. Once initialized, a given Ozone instance can respond to tens of thousands of requests, which makes it worthwhile to run a lot of pre-processing and pre-caching operations during initialization.</li>
	<li><strong>It's safe</strong>. I use a programming style that relies on avoiding exceptions, never using wildcards, defining many new types for almost everything, and writing pure functional code. This eliminates entire realms of bugs : using the wrong variable, forgetting to call a function or catch an exception, being surprised by a sneaky side-effect or doing things in the wrong order... About half the bugs I caught using Unit Tests don't exist in OCaml (null reference exceptions, anyone?) and the other half is eliminated by my programming style — so I don't write unit tests anymore (well, I do write an automated "test" every time I find a bug, but it's usually as simple as adding a  type annotation). This also lets me routinely refactor literally half the application every other week, without causing any bugs.</li>
	<li><strong>It's concise</strong>. Most of the features I write are a matter of a mere hundred lines — most of the code is related to my obsessive need for being explicit. Being a functional language, you can define a brand new anonymous function on the spot and throw it into another function that is returned by yet another function which is then given to yet <em>yet</em> another function, all of it being implicitly type-checked without having to define a single <em>IAcceptsBoxObserver</em> interface or <em>LeafBoxObserver</em> implementation.</li>
	<li><strong>It has a fast compiler</strong>. Building those 30KLOC from scratch takes less than a minute — the average incremental build takes one or two seconds. Whenever I have any doubts about what I'm writing, I can just ask the compiler — <em>Hey, did I forget anything about this function call? Why yes, master, you forgot to check that the user was indeed allowed to reply to that message.</em></li>
</ul>
The most essential feature is complete compile-time safety. As a web programmer, I have to be careful about hundreds of small details — can this text be translated into another language? Is this user allowed to do what they just did? Did that object disappear from the database while you were editing it? Does that URL really correspond to an actual page? Did you remember to check for script injection in that piece of HTML? Is this GET parameter available at this point in the code? Is this object available or locked by another user? Did I forget anything else? It's impossible for a human brain to think about all these things while at the same time creating an elegant design or refactoring a piece of code or writing a new feature. I can use the flexible OCaml type system to check for all these details through appropriate design of the Ozone API, which turns the development process into a game of <em>1° write the simplest code that works, 2° listen to the compiler's suggestions for making it fail-proof</em>. It's a game that I'm becoming fairly fond of, and it lets me concentrate on the very core of what I'm trying to do.
<h4>Disadvantages of OCaml</h4>
It's not a happy fun place. Quite the contrary: the language comes with a set of annoying quirks and flaws that do make things harder. Before you jump in, you should know what to expect.
<ul>
	<li><strong>Type-safety has a price</strong>. If the type system cannot express a certain thing, then you can't do it. There are a few fairly complex examples where this has caused me trouble, in areas such as optional function arguments, module meta-programming, JSON serialization or dynamic database-driven data structures. Workarounds exist, but they're only workarounds. Another side-effect is that type inference can make it hard for inexperienced developers to find an error, especially if you do a lot of strange type wizardry. Not to mention the silly yet annoying "<em>this expression has type foo but is used here with type foo</em>" error.</li>
	<li><strong>Lack of tools and libraries</strong>. Being a non-mainstream language means there are no heavily tweaked and highly evolved tools available (think about the wealth of tools available for C# or Java development), which gives a certain clunky feel to development. Besides, many libraries which are taken for granted in the mainstream world are missing or non-documented — try connecting to the Facebook API and you'll notice that not only there is no Facebook SDK in OCaml, but <em>there is also no documented way of using HTTPS</em>. The same goes for Amazon S3 and MD5-based HMACs, by the way. And <em>iconv</em> functionality. And removing the <em>X-Mailer</em> header from e-mail you send. The list goes on.</li>
	<li><strong>It's not object-oriented</strong>. You can use classes and mutable objects — it's a viable implementation strategy, but it also bears a lot of the typical issues encountered in the mainstream programming languages, and it lacks the conciseness of functional approaches (defining a class and instantiating an object is bound to be longer than a lambda). If you're not in the right mindset for using the language, you will miss on a lot of the benefits.</li>
	<li><strong>It's not popular</strong>. It <em>is</em> a disadvantage, just not a <em>technical</em> one. As a programmer I couldn't care less about the popularity of my language because, you know, <em>COBOL</em> was very popular once. As a hiring manager, I am aware that using a non-popular language will make hiring developers harder. As a start-up founder, I know that this reduces my chances of selling my company because esoteric technologies are a risk to potential buyers.</li>
</ul>
There are also many tiny quirks in the language that I hope would eventually be solved. For instance, there's the absence of a shorthand notation for the ubiquitous <code>(fun x -&gt; x # member</code>). There's also the lack of C#-like properties, with a pure functional twist:
<pre style="padding-left: 30px;"><code>val x = init

method get_x    = x
method set_x x' = {&lt; x = x' &gt;}</code></pre>
And, of course, there is a lot of things going on with the option type that <em>BatOption</em> just isn't up to expressing concisely. The P4 preprocessor <em>could</em> be applied to these situations fairly reasonably, but I would feel more comfortable if they were built into the language (and syntax highlighting tools).

In conclusion, OCaml + CouchDB provide our team with the flexibility required to build new features frequently without being afraid of subtle bugs or regressions, and to regularly refactor our code into a more amenable mess. It is a level of compiler-provided safety, surgical refactoring and bug detection that would be simply unavailable with C# and Java (and hopeless with PHP, Python or Ruby).

<small>¹ <a href="http://www.runorg.com/" target="_self">RunOrg</a> is my Start-Up ; we provide an online tool that helps associations, unions, organizations and communities manage their members, contacts, activities, events, knowledge and online presence.</small>