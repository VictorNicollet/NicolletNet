@title So, What's Your Name?
@draft

I've been having a lot of name-related problems, lately. Not my own name, but the names of various things I have to work with. Nothing unexpected: in the computer world, we tend to use names everywhere.

Every time there are objects to be manipulated by programmers, there's a way to give names to these objects. It could be the "id" attribute in XML, it could be the name of a file in a filesystem, it could be the name of a variable or member in a program, or it could be the hostname of a web site... A name is, in theory, a set of characters from a predetermined alphabet (that varies based on the application) which is bound to an entity of some sort. Once you hold the name, you can get the associated entity directly.

This theoretical definition leads to two distinct issues:
<ul>
	<li>There's only a small number of acceptable names around. Of course, generic names like "clxbpf8990" can be used (and if you look at the ids generated by generate-id() in XSLT, this is exactly what happens) but the entire point of a name is to allow people to retrieve content based on the name. As far as the internet goes, there's only a finite number of names any user can remember—and web users have become increasingly reliant on google and the recently added Firefox 3.0 address bar to find sites with non-obvious names. How do we handle the inevitable collisions?</li>
	<li>A programmer in Australia has a global variable named Foo in a C program. A programmer in Sweden, working on a different C program, also has a variable named Foo. Should the two collide? What about machine names on local networks? User names on the same machine? Not all names are global, which means that the scope of names has to be determined, and ways of handling collisions between local scopes must be invented.</li>
</ul>
Yet, it's not all about collision. The most important element of naming is the ability to find the data bound to a name. This is what directories are for.

The simplest form of directory is the phone directory: you have a name on the left, and a phone number on the right. The directory also happens to be sorted by ascending key order so that dichotomic search can be used to find a given name in logarithmic time (how clever—in the age of search engines, we tend to forget logarithmic search times existed since the days of dictionaries and encyclopedias). Such directories exist in the computer world. The simplest would be the classic user directory, accessed through LDAP (Lightweight <strong>Directory</strong> Access Protocol) or perhaps Active<strong>Directory</strong>, but these are not the most frequently encountered by the common user. Another simple example is /etc/passwd:
<pre style="padding-left: 30px;">username:!:100:100:office:/home/username:/usr/bin/sh</pre>
User name is on the left, various user-related information is to the right.
<h2>Domain Name System</h2>
Let's crank the complexity lever up a little bit. What classic directory format do we use several times a day? The Domain Name System (which most of you know as DNS). Everyone sends out queries to a DNS server, asking for the IP associated with a name. That is, when you type "www.nicollet.net" in your browser, the browser needs to know what server to connect to. The problem is that looking for a server is done by routers, which are usually not very smart: they have routing tables based on masking the IP address (whether that address is IPv4 or IPv6) so they need that address to begin with. So, the browser instead resolves the domain name to an address. This involves looking at the local "hosts" file to see if a definition exists (for instance, "localhost" tends to be bound to the loopback address "127.0.0.1"), then queries any local name services the operating system may provide (this allows you to connect to an HTTP server running on another machine on your network by using that machine's name, without having to set up a local DNS server or registering with a public one), and finally sends out a query to a DNS server somewhere on the internet (the address of the DNS server is either provided by the ISP itself, or manually entered by the user in a configuration wizard or file). The DNS then returns the address for the domain.

This is where two of my recent name problems came from. As you might remember, one week ago I had to move my blog from one server to another, and in the process, I had to change the DNS entry so that reads who typed in "www.nicollet.net" connected to the new server instead of the old one.

The first issue was that DNS propagation is not instantaneous. Back in the days when the intertubes were often clogged, caching played a big role in avoiding too many DNS queries moving up to the reference DNS server for a given top-level domain. The downside is that when you type in "www.nicollet.net", you're not really asking the reference DNS server for domains ending in ".net", you're asking the DNS server provided by your ISP, which may decide that its copy of the "www.nicollet.net" address binding is correct, without even asking the reference server (this is what caching is for). So, it took about five hours for all visitors to be correctly redirected to the new website. If any of you posted any comments, they went to the old website and were lost along with it—sorry. Of course, as you can expect, this can get a lot more problematic once you have a highly interactive website. So, you tend to choose an IP address and stick with it (or, if you have to change it, then you have it forward everything to the new one until nobody uses it anymore).

This also meant that any e-mails sent to foobar@nicollet.net were routed to the old MX binding, "mx1.ovh.net" (for those who wonder, a DNS entry contains several bindings: a web browser would look at the main binding for that domain, while a mail delivery program would look for the Mail eXchange binding) even though I was expecting them on the new MX binding, "nicollet.net".  This took a short while to be sorted out.

The second issue was with the name of the server. See, being listed in a directory doesn't <em>change</em> your name: it merely gives you a name by which you can be found. So, the name of the famous emperor of Wei is still Cao Cao, despite being posthumously named Wu. And the name of my new server still was r17474.ovh.net despite being now referred to as nicollet.net by the DNS. Then, of course, when some mail arrived for the user foobar@nicollet.net, my qmail-powered server quite naturally answered "there's no user named foobar@nicollet.net here, please go away" in perhaps not so polite terms. So, I still had to convince my server that it was now known as "nicollet.net" so that the mail delivery could work. Nothing that the "hostname" UNIX command couldn't solve.

What about local area networks? How come that you can access another machine on your network by using its name? There usually isn't a central naming service which can be queried by computers on a LAN, and it wouldn't be practical because it would have to be manually configured on every new computer. Instead, computers on a LAN use NetBIOS to set up local directories: whenever a new computer is hooked up to the network, it broadcasts its hostname and address to everyone else, and everyone else writes down the association in a local directory. Conflicts are resolved quite simply: if two computers have the same name, the last to broadcast is the one that everyone else remembers (this is quite useful if you have to move from an office to another and get a new IP as a consequence).
<h2>Names in Languages</h2>
Programming languages all provide the user with ways of naming entities that are significant, both for documentation purposes (it's easier to understand what a value is when it has a reasonable name) and for cross-referencing data defined in one place and used in another.

On the one hand, you have the static compile-time approach. This is the easiest to work with by far, because all the nitty-gritty details are written down in the documentation of the compiler and the build scripts of your application. For instance, most compilers allow the definition of "include paths", a list of locations on the filesystem where the definitions of objects can be found. When the compiler needs something (an included file in C or C++, a class in Java or Actionscript, a module in Objective Caml), it will look for an appropriately named file in all these locations.

Let's consider the Objective Caml compiler, "ocamlc". Whenever a source file contains a reference to another module (by using a symbol in a module context, such as "ModuleName.member" or "Functor(ModuleName)" or "open ModuleName" or something like that), the compiler looks for the <em>compiled interface</em> of that module. This is done by looking for the file "moduleName.cmi" (which is generated manually by running "ocamlc moduleName.mli") in all the locations configured with the compiler: first, the current directory, then paths specified through the environment variables, then include paths specified with the -I command-line argument. If you're only compiling the module (flag -c), the result is a <em>cmo</em> file (or <em>cmx</em> file with "ocamlopt"). At link-time, you must then specify all the <em>cmo</em> files required by the program, and the compiler resolves all links based on the name of the cmo file (for simplicity, it's possible to group together several cmo files as a single <em>cma </em>file : they are simply concatenated together, so using the <em>cma</em> library is equivalent to adding all the <em>cmo</em> files it contains manually).

Java goes a short step beyond this by eliminating the need for a link step. When you import a java class, using the "import abc.def.Foobar;" statement, java understands that by looking at the relative path "abc/def/" it will find either a "Foobar.class" or a newer "Foobar.java" that it can compile to "Foobar.class". Here, the path is specified relative to one of the include paths (which Java calls classpaths) and can be a normal filesystem path or a path within a JAR archive.

C and C++ are both the simplest and the most complex. In these languages, every reference is explicit. The first step is compilation, where files are included in other files by specifying the relative path. The second step is linking, where libraries and objects are included by specifying the relative path. At each step, additional locations can be specified to look for headers.

PHP has an interesting dual approach to things. On the one hand, its normal cross-file interpretation system consists in include() and require() statements which look for the named file in any of the specified include paths for PHP, which makes it look like SH, C and C++. On the other hand, PHP has also introduced functionality for resolving class names: when a class is used ("ClassName::Member", "Foobar extends ClassName" or "new ClassName") but the class is not defined, a special function is called. This lets the user specify an alternative loading scheme, such as looking for a file named ClassName.php and including it. The Zend Framework makes heavy use of this, meaning that the inclusion approach is specified once in index.php (or a common configuration file) and then no other inclusion is used for class filed (arguably, Zend_View still includes phtml files explicitly).

On the other hand, there's runtime access. This is harder to work with, because there's less documentation available. Sure, some concepts, such as dynamic linking, are fairly well-documented mechanisms that look for the named file in the current directory first, then in other directories specified as environment variables or system-wide configuration elements (in the case of java, in the classpath, for example). However, even then, some programs insist on working on their own.

I recently had an issue with Alfresco, namely alfresco-mmt.jar which terminated with a ClassDefNotFound exception. Looking for solutions on the internet, I found out that the class it was looking for was defined in a JAR nearby, so I adapted the classpath when running the jar so that the class could be found. Except it couldn't. The problem with this was that the exception did not specify where the class loader had been looking for the class (or perhaps it did internally, but as an end user with no access to the source code or, probably, a debugger, I couldn't see it), so I had no way of understanding where the JAR with the class should have been placed. It turns out, the application loaded the JAR from inside its own JAR, so I had to place it there.